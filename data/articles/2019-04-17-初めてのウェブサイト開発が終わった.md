---
layout: post
categories: blog
tags: [development]
description: |-
  人生初めてのアプリケーション開発を終えて、改めて今の気持ちを語ってみたい。
toc: true
---

私は1つの挑戦を終えた。
長く続けてきたアプリ開発を終え、今日リリースできた。
本職はプログラマーであるが、主な業務内容はバックエンドシステムの保守・運用であり、UIを持つアプリケーションを0から開発する経験がなかった私にとって、大仕事だった。

今はとても気持ちが良い。
このような充実感を得ることができたのは久しぶりである。
この充実感があるだけで、私は今回の取り組みに成功したと言える。
とは言え反省点もあるだろう。
ここでは一切を振り返りたいと思う。

ざっくりとした成功の要因を書き、失敗した要因は書かない。
なぜなら、成功した要因は失敗した要因の裏返しでもあるからだ。
成功した要因が「XXXをしろ」である場合、失敗した要因は「XXXをしないこと」である。
成功した要因が「XXXをするな」である場合、失敗した要因は「XXXをしてしまうこと」である。

## アプリの完成像が完全にイメージしろ

今回参考にしたのは、既存の某アプリであった。
既存のアプリをほぼほぼ丸ごと忠実に再現すればよかった。
つまり、完成像を明確に、詳細に、至るまでイメージすることができた。

ゴールを明確にすることが重要であるという話はよくあるが、こうも違うものかと思った。
次回から、作る前にアプリの完成像を、明確に、詳細に、Scketch appなどを用いてプロトタイプを作り込むようにすると良いだろう。
プロトタイプの作成で詰まるようなら、そのアプリの開発はやめた方が良いかもしれない。

## みんなが使ってくれそうなアプリを作れ

今回はあまりネタに走ることがなく、オーソドックスに、世の中によくあるアプリの亜種として、私のアプリを開発した。
これにより、長期の開発におけるモチベーションを持ち続けることができた。
アプリが完成した後で、みんなに使ってもらうのだ！というインセンティブにどれだけ助けられたことか。

車輪の再発明と言われると、その通りであり、返す言葉がない。
しかしながら、誰が使うかもわからない、話題性だけを目当てとしたネタアプリを作ることに、私のモチベーションは続かない。
特に、長期戦が予想される場合このモチベーションの維持は必要不可欠となる。

## アプリ開発の動機は明確であり、かつ、内発的なものであるべきだ

何故私は今そのアプリを作るのか？明確であり、かつ、内発的な承認欲求であった。
今回は、Angularjs6、Golang、GCPの習得、さらに、男になるための通過儀礼のために、生き甲斐のために、フラストレーションの発散のために、アプリを開発した。

動機が内発的であることにより、完成後のアプリがヒットしないかもしれない、という不安を除去できた。
なぜなら、アプリがヒットするかどうか？はどっちでも良いのだ。
アプリがヒットしなくても、アプリを完成するというだけで内発的な承認欲求は満たされる。結果など副産物に過ぎなくなる。

私にとって、誰かと仲間になりたい、有名になりたい、金を儲けたい、という欲求は外発的なものだ。
外発的な承認欲求は外部の情勢により左右され、自分がどれだけ努力しようとも、その承認欲求は満たされない可能性が高い。
そのような外発的な承認欲求を、開発の動機にすべきでない。結果的に誰も得しないから。

## 時間をかけ、やり続けろ。細く長くでも良い。

今回、あらゆるものを切り捨てて、アプリ開発に時間を投資した。
そして、毎日少しずつ継続した。その期間は半年である。
長く継続的な開発により、開発という行動そのものを習慣化することができた。

さらに今回思い知らされたことは、クォリティの良さはかけた時間の大きさに比例する、ということだ。

次からは、何か結果の出る挑戦をやろうと思うのであれば、半年ぐらいの時間はかかり、毎日継続しなければならないということを、当たり前のように思うべきである。

## 最終ゴールを小さなゴールに分解し、達成し続けろ

最終ゴールを小さなゴールに分解し、それらのゴールに対応するGithubのissueを作成し、GithubのProjectによりグルーピングし、その後優先度を付け、issueを1つずつ片付けた。

現在どの程度の作業が完了し、残されているのか、という点について定点観測できることにより、モチベーションが維持される。

## ユニットテストは後回し

ユニットテストを書く作業には、とてつもなく時間がかかる。
仕事では、絶対にユニットテストを書くべきである。
しかしながら、今回のような個人的な開発案件に関しては、開発に充てる事ので当てる事のできる時間は、仕事から帰った後の2〜3時間である。圧倒的に時間が足りない。
従って、ユニットテストは後回しにすべきである。

断っておくが、仕事においては、必ずユニットテストを書くべきであるし、ユニットテストを書くための時間を開発の時間に加え、プロダクトオーナーにリソースを捻出してもらうための交渉をすべきである。

## 速すぎる最適化は悪。コード量が大きくなってもかまわない。

今回は開発にかけられる時間が少なかったので、プログラムを詳細に構造化する時間が十分に取れなかった・・・というよりは、プログラムの構造の設計をせずに、どんどんソースコードを書いていった。

その結果、あっという間にソースコードの量が大きくなった。そして、それらのソースコードは汚なかった。ファイル名・命名には明確な規則がなく、不要になった関数はそのまま放置され、重複したコードが多数存在した。

それでも良かった。
この時点でプログラムを構造化することは、速過ぎる最適化だ。
開発当初、プログラムのインターフェースを適切に定義することは重要であるが、そのプログラムの内部構造は汚くても良いのだ。
そもそも私自身、プログラムを厳密に構造化をしたところでその恩恵を享受した経験が少ない。
プログラムを書く上では、構造化よりも重要な指針があると思っている。

私は、構造化を行わなかったが、いくらかの指針を掲げ、それだけは守った。なぜなら、これらの指針が守られていないソフトウェアは、非常にアップデートし難くなることを経験的に知っていたからだ。ソフトウェアを書く際にもっとも重視すべきことは、そのソースコードをアップデートし易くしておくこと、である。

以下は、私が守った指針である。

### ソフトウェアの全体像から書き始め、徐々に詳細を書いていく

良いソフトウェアは適切にモジュール化され、複数のモジュールが組み合わされて構築されている。
ソフトウェアを0から書き始める場合、どのようにモジュール化したら良いか？を考え、そのインターフェースだけが定義された空のモジュール（モジュールの中身では何も処理をしない）を定義し、それらのモジュールを組み合わせてソフトウェアの全体を書くことである。モジュールの中身は後回しで良い。

このようにすることで、ソフトウェアの機能をどのようにモジュール化したら良いか？に対して思考を集中投下させることができ、結果的により良い設計となる。
### クラスにはインターフェースを保持させ、クラスを保持させてはならない。

Goにおいて、インターフェースとクラス(ここではクラスとは、メソッドを持つ構造体のことを指す)は違うものだ。インターフェースはモックすることができるが、クラスはモックにすることができない。モックすることができないクラスを保持させてはならない理由は、ユニットテストが書きにくくなるからだ。従って、モジュールのメンバー変数には、インターフェースを保持させておくべきである。

しかしながら例外的に、以下の場合、クラスを保持させても良い。

* 非常にサイズの小さいクラス
* モック用のライブラリやツールが存在するクラス。`http.Client`,`db.DB`,Google App Engineにより提供されるいくつかの機能。
* メソッドを持たないクラス

繰り返すが、クラスにクラスを保持させてはならない理由は、ユニットテストを書く際にモックできないからである。従って、モックする必要のない場合、或いはモック用のライブラリやツールが別途用意されている場合に関しては、クラスにクラスを保持させても良い。

### モジュールを階層的にする

私がよくやる手法として、OSI参照モデルのようなモジュールの階層化がある。

どんなに複雑なプログラムであっても、所詮は様々な単純な機能が組み合わされ、複雑な機能が実装されているだけである。単純な機能をどのように組み合わせていくか？これが重要である。

その方法は以下である。
複雑な機能を単純な機能に分解し、それらの分解された機能を再度いくつかのグループに分類し、その分類ごとにパッケージを作る。1つのパッケージでは、そのパッケージがやるべきこと以外のことはしない。
こうすることで、OSI参照モデルのようにソフトウェアの機能を階層化できる。そしてこの階層化はわかりやすいものである。

### クラスのメソッドは最小限にする

今回、迷ったらメソッドにしない、という指針のもとで開発を進めた。

メンバー変数をクラスは、その時の状態に左右され、実行時の振る舞いが変化するものであるため、メソッドを1つ作るごとにそのクラスの複雑度は指数関数的に増大する。
を持たない関数により実現できるのであれば、メソッドを持たせるべきではない。とはいえ、メソッドにすることでプログラムの可読性は上がるというメリットもある。そのトレードオフを十分に検討し、メソッドを持たせるかどうかという判断をすべきである。

### クラス、或いは、インターフェースを相互依存させてはならない

クラスやインターフェースの相互依存はすべきでない。何故なら、プログラムが複雑になるからである。

### 先行きが不安なサードパーティ製ライブラリはラップしておく

サードパーティ製のライブラリの中には、非常に便利だが先行きの怪しいものがある。ライブラリのアップデート頻度やコントリビュータが少なかったり、最終アップデートから何年も経っていたり。このような場合、ライブラリを直接使用するのではなく、何かしらのパッケージ、クラス、インターフェースにより、その振る舞いを限定させておくためのラッパーを作成し、そのラッパーを通してライブラリを使用すると良い。

このようにしておけば、使用していたサードパーティ製のライブラリがダメになっても、ラッパーのインターフェースに変更を加える必要はないため、呼び出し元コードへの影響が小さくて済む。

### グローバル変数を定義してはならない

言うまでもないが、定数はグローバル変数でも良い。

## ユーザー体験の確認が最優先

ユーザーがそのアプリに求めているものは何だろう？
無論、綺麗なソースコードや設計などではなく、より良い体験である。
お前はプログラムの内部設計、或いは、リファクタリングをしているのか？そうでない場合、プログラムを書いて、ソースコードをいつまでも眺めるているのはやめろ。

お前がやるべきことは、そのアプリを使い、ユーザー体験を確かめることだ。
使いやすいか？イメージ通りに作れたのか？

### 開発以外の繰り返し実施される単純作業は自動化しろ

今回、機能を徐々に追加していったので、最終的なリリースまでの間に、何度もリリースした。
このリリース作業は早い段階で自動化し、手間がかからないようにした。

## 全ての作業を、後から確認できるものにしておけ

作業の履歴は全てissueに残した。

## 開発言語は限定しろ

GoとTypeScript(JavaScript)以外の言語は使わなかった。

## VSCodeを使え

VSCodeのlinterや補完機能を使用したお陰で、随分と開発効率が上がった。

## 気分転換を用意しておけ
## あとは最後は不屈の精神だけ